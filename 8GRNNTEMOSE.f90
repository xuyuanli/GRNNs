!  8GRNNTEMOSE.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  3/28/2013 4:12:38 PM
!  Compiled by XUYUAN LI
!  The University of Adelaide
!  Open sources code (application version) for the following journal paper:
!********************************************************************
! Li X., Zecchin A.C. and Maier H.R. 2014, 'Selection of smoothing parameter estimators 
! for General Regression Neural Networks - applications to hydrological and water resources modelling', 
! Environmental Modelling and Software, accepted May 6, 2014
!********************************************************************

Module GRNN_TEMOSE
  use GFS

contains

!*****************************PSO MAIN****************************************  
Subroutine PSOA(ix,oy,r,c,sp)  

USE mod_PSO, ONLY: type_PSO_swarm, read_PSO_swarm_from_file, initialise_PSO_swarm,&
re_initialise_PSO_swarm, update_PSO_swarm_bests, update_PSO_swarm_parameters,&
update_PSO_swarm_locations, perturb_PSO_swarm_locations,& 
store_PSO_iteration_data,print_PSO_swarm_iteration_statistics
        
    IMPLICIT NONE
    real(8)::ix(:,:),oy(:)
    integer(8)::r,c     
    TYPE(type_PSO_swarm), TARGET:: swarm
    REAL(8):: f
    INTEGER(8):: i, j 
    real(8)::sp(:)

    
    CALL set_PSO_parameters(swarm)
    CALL initialise_PSO_swarm(swarm)
! Performing optimisation 
    DO i = 1, swarm%NImax 
      CALL update_PSO_swarm_parameters(swarm,i)
	  DO j = 1, swarm%Nparticle
! Evaluating the particle objective function values
        CALL ComputeObjectiveFunction(ix,oy,r,c,(0.0001+3.9999*(swarm%particle(j)%x)),f)  
        swarm%particle(j)%f = f
	  END DO
! Adjusting the PSO parameters
      CALL update_PSO_swarm_bests(swarm)
	  CALL store_PSO_iteration_data(swarm,i)
      CALL update_PSO_swarm_locations(swarm) 
	END DO
	
	!CALL print_PSO_swarm_iteration_statistics(swarm, 10_8)
	
	do i=1,swarm%Nx
	    sp(i)=0.0001+3.9999*swarm%GB(1)%x(i)
	end do
  
  CONTAINS
!==================================================================================================
  SUBROUTINE set_PSO_parameters(swarm)
  
    USE mod_PSO, ONLY: type_PSO_swarm
  
    TYPE(type_PSO_swarm), INTENT(INOUT) :: swarm
    
    ! Control Parameters
    swarm%NeighbourhoodFlag = 'vonNeumannU' ! Type of neighbouthood structure
	swarm%Nparticle         = 50           ! Number of particles
	swarm%Nelite            = 2             ! Number of elitist particles
	swarm%NImax             = 100         ! Maximum number of iterations
	swarm%Nx                = 3             ! Size of decision string
	! Standard searching parameters
	swarm%cNB               = 2.0		    ! Weighting coefficient for GB particle 
	swarm%cPB               = 2.0		    ! Weighting coefficient for PB particle
	swarm%cInertiaMax       = 0.9		    ! Maximum inertia coefficient
	swarm%cInertiaMin       = 0.4		    ! Minimum inertia coefficient
	swarm%vMax              = 0.5		    ! Velocity component bound
	! Secondary searching parameters (not needed unless difficult problem, set swarm%perturbNI > swarm%NImax to not use)
	swarm%perturbExp        = 5.0		    ! Perturbation Exponent
	swarm%perturbProb       = 0.20		    ! Perturbation Probability
	swarm%perturbEs         = 0.000005	    ! Expected value for start
	swarm%perturbEe         = 0.0000000005	! Expected value for end
	swarm%perturbNI         = 10001		    ! Start iteration for perturbation
  
  END SUBROUTINE set_PSO_parameters
!==================================================================================================
  SUBROUTINE ComputeObjectiveFunction(x,y,xr,xc,hg,ESSO)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:,:),y(:),hg(:)
    INTEGER(8), INTENT(IN) :: xr,xc
    REAL(8),INTENT(OUT) ::ESSO 
    real(8),allocatable::ye(:)
    integer(8)::c1
    
    allocate(ye(xr))
  
  call GRNN(x,y,xr,xc,hg,ye)
  
  ESSO=0.0
  do c1=1,xr
     ESSO=ESSO+(ye(c1)-y(c1))**2.0     !MAE
   end do
   ESSO=ESSO/real(xr) 
   
    deallocate(ye)
   
  END SUBROUTINE ComputeObjectiveFunction
!==================================================================================================
end subroutine


!*************GRNN prediction with trial & error (SO)************
subroutine BW_TEMOSE(fc1,inx,outy,nr,nc)
implicit none

real(8),intent(in)::inx(:,:),outy(:)
integer(8),intent(in)::fc1,nr,nc
integer(8)::c1,c2,c3,c4,fc2,fc3    !counters
real(8),allocatable::sd(:),bw(:),outyest(:),h1(:),t1(:)
real(8)::a1,a2,a3,a4,tmin
real(8)::mins,maxs,vars,kurts,rmses,mares,ces,ioads,pis,as,ss,& 
mces,mioads,mpis !Performance criteria

allocate(sd(nc))
allocate(bw(nc))
allocate(outyest(nr))
allocate(h1(10))
allocate(t1(10))

bw=0.0

!Estimate bandwidths (GRR)
call PSOA(inx,outy,nr,nc,bw)

!GRNN prediction
call GRNN(inx,outy,nr,nc,bw,outyest)

!Performance criteria
call SPOM(outy,outyest,nr,mins,maxs,as,vars,ss,kurts)
call RMSE(outy,outyest,nr,rmses)
call MARE(outy,outyest,nr,mares)

call CE(outy,outyest,nr,ces)
call IoAd(outy,outyest,nr,ioads)
call PI(outy,outyest,nr,pis)

call MCE(outy,outyest,nr,mces)
call MIoAd(outy,outyest,nr,mioads)
call MPI(outy,outyest,nr,mpis)

!Output summary
!Detial results
write(fc1,*)"Estimated output:"
do c1=1,nr
   write(fc1,*)outyest(c1)
end do
write(fc1,*)

write(fc1,*)"Prediction performance:"
write(fc1,*)"Min. error %:",mins
write(fc1,*)"Max. error %:",maxs
write(fc1,*)"Mean. error:",as
write(fc1,*)"Stdev. error %:",vars
write(fc1,*)"Skew. error %:",ss
write(fc1,*)"Kurt. error %:",kurts
write(fc1,*)"RMSE:",rmses
write(fc1,*)"MARE:",mares
write(fc1,*)"CE:",ces
write(fc1,*)"IoAd:",ioads
write(fc1,*)"PI:",pis
write(fc1,*)"MCE:",mces
write(fc1,*)"MIoAd:",mioads
write(fc1,*)"MPI:",mpis
write(fc1,*)"******************************"

!Overall results
fc2=fc1+100
write(fc2,'(14F11.5)')mins,maxs,as,vars,ss,kurts,rmses,mares,ces,&
ioads,pis,mces,mioads,mpis

!Smoothing parameters
fc3=fc2+100
write(fc3,*)(bw(c2),c2=1,nc)

deallocate(sd)
deallocate(bw)
deallocate(outyest)
deallocate(h1)
deallocate(t1)

end subroutine



end Module
