!  GRNNSCV_test.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  3/11/2013 4:49:34 PM
!  Compiled by XUYUAN LI
!  The University of Adelaide
!  Open sources code (application version) for the following journal paper:
!  ********************************************************************
!  Li X., Zecchin A.C. and Maier H.R. 2014, 'Selection of smoothing parameter estimators 
!  for General Regression Neural Networks - applications to hydrological and water resources modelling', 
!  Environmental Modelling and Software, accepted May 6, 2014
!  ********************************************************************

Module GRNN_SCV
  use GFS
  contains

!Optimiser 1D (GSS)
!This code is based upon 'NUMERICAL RECIPES IN FORTRAN77: THE ART OF SCIENTIFIC COMPUTING
!Routine for Golden Section Search
!Input boundary values, mid-value
!return the value minimising function
subroutine GSS(ax,bx,cx,in,r2,c,minf,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),c
integer(8),intent(in)::r2
real(8),intent(out)::minf,minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=SCVh(in,r2,c,x1) !Initial evaluation
f2=SCVh(in,r2,c,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=SCVh(in,r2,c,x2)
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=SCVh(in,r2,c,x1)   
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine
!****************************End of GSS*********************************

!Function SCV(h)
real(8) function SCVh(xs,ns,cs,hs)
implicit none
real(8),intent(in)::xs(:),cs
integer(8),intent(in)::ns
real(8),intent(in)::hs
real(8)::oh
integer(8)::c1,c2
real(8)::sum1,sum2,sum3,sum4,sum5,sum6

!g=cs*ns**(-23.0/45.0)*hs**(-2.0)

sum1=0.0
sum2=0.0
oh=(2.0*hs**2.0+2.0*(cs*ns**(-23.0/45.0)*hs**(-2.0))**2.0)**0.5        !Updated
do c1=1,ns
   do c2=1,ns
      sum1=(xs(c1)-xs(c2))**2.0/2.0/oh**2.0
      sum2=sum2+dexp(-sum1) 
   end do
end do   
sum2=((2*3.141592653)**0.5*oh)**(-1.0)*sum2

sum3=0.0
sum4=0.0
oh=(hs**2.0+2.0*(cs*ns**(-23.0/45.0)*hs**(-2.0))**2.0)**0.5            !Updated
do c1=1,ns
   do c2=1,ns
      sum3=(xs(c1)-xs(c2))**2.0/2.0/oh**2.0
      sum4=sum4+dexp(-sum3) 
   end do
end do   
sum4=((2*3.141592653)**0.5*oh)**(-1.0)*sum4

sum5=0.0
sum6=0.0
oh=(2.0*(cs*ns**(-23.0/45.0)*hs**(-2.0))**2.0)**0.5                     !Updated
do c1=1,ns
   do c2=1,ns
      sum5=(xs(c1)-xs(c2))**2.0/2.0/oh**2.0
      sum6=sum6+dexp(-sum5) 
   end do
end do   
sum6=((2*3.141592653)**0.5*oh)**(-1.0)*sum6

SCVh=(ns*hs)**(-1.0)*(2*3.141592653**0.5)**(-1.0)+(sum2-2.0*sum4+sum6)/ns/ns  !Updated

end function
!****************************Function SCV(h)***************************

!Function factorial
integer(8) function fact(x)
implicit none
integer(8),intent(in)::x
integer(8)::i

fact=x
do i=1,(x-1)
   fact=fact*(x-i)
end do

end function
!*****************************End Fact**********************************
!Psi estimation with normal density (Wand& Jones 1995) pp.72
real(8) function psiNS(o,sd1)
implicit none
integer(8),intent(in)::o
real(8),intent(in)::sd1  !order, data standard deviation, Psi at given order

psiNS=((-1.0)**(o/2.0)*fact(o))/((2*sd1)**(o+1.0)*fact(o/2)*3.141592653**0.5)

end function
!*****************************End PsiNS*********************************
!Generl Psi estimation (Wand& Jones 1995) pp.67
!K(10)
subroutine psi10(x,g,n1,psiv)
implicit none
real(8),intent(in)::x(:),g  !input, pilot bandwidth, general psi at given order
integer(8),intent(in)::n1
real(8),intent(out)::psiv   !general psi at given order
integer(8)::c1,c2
real(8)::sum1,sum2

sum1=0.0
sum2=0.0
do c1=1,n1
   do c2=1,n1
      sum1=(x(c1)-x(c2))**2.0/2.0/g**2.0  
      sum2=sum2+(-945.0*dexp(-sum1)/g**8.0&
      +4725.0*(x(c1)-x(c2))**2.0*dexp(-sum1)/g**10.0&
      -3150.0*(x(c1)-x(c2))**4.0*dexp(-sum1)/g**12.0&
      +630.0*(x(c1)-x(c2))**6.0*dexp(-sum1)/g**14.0&
      -45.0*(x(c1)-x(c2))**8.0*dexp(-sum1)/g**16.0&
      +(x(c1)-x(c2))**10.0*dexp(-sum1)/g**18.0)    
   end do
end do
psiv=n1**(-2.0)*((2.0*3.141592653)**0.5*g**3.0)**(-1.0)*sum2    

end subroutine

!K(8)
subroutine psi8(x,g,n1,psiv)
implicit none
real(8),intent(in)::x(:),g  !input, pilot bandwidth, general psi at given order
integer(8),intent(in)::n1
real(8),intent(out)::psiv   !general psi at given order
integer(8)::c1,c2
real(8)::sum1,sum2

sum1=0.0
sum2=0.0
do c1=1,n1
   do c2=1,n1
      sum1=(x(c1)-x(c2))**2.0/2.0/g**2.0  
      sum2=sum2+(105.0*dexp(-sum1)/g**6.0&
      -420.0*(x(c1)-x(c2))**2.0*dexp(-sum1)/g**8.0&
      +210.0*(x(c1)-x(c2))**4.0*dexp(-sum1)/g**10.0&
      -28.0*(x(c1)-x(c2))**6.0*dexp(-sum1)/g**12.0&
      +(x(c1)-x(c2))**8.0*dexp(-sum1)/g**14.0)    
   end do
end do
psiv=n1**(-2.0)*((2.0*3.141592653)**0.5*g**3.0)**(-1.0)*sum2    

end subroutine

!K(6) 
subroutine psi6(x,g,n1,psiv)
implicit none
real(8),intent(in)::x(:),g  !input, pilot bandwidth, general psi at given order
integer(8),intent(in)::n1
real(8),intent(out)::psiv   !general psi at given order
integer(8)::c1,c2
real(8)::sum1,sum2

sum1=0.0
sum2=0.0
do c1=1,n1
   do c2=1,n1
      sum1=(x(c1)-x(c2))**2.0/2.0/g**2.0  
      sum2=sum2+(-15.0*dexp(-sum1)/g**4.0&
      +45.0*(x(c1)-x(c2))**2.0*dexp(-sum1)/g**6.0&    !K(6), checked
      -15.0*(x(c1)-x(c2))**4.0*dexp(-sum1)/g**8.0&
      +(x(c1)-x(c2))**6.0*dexp(-sum1)/g**10.0)     
   end do
end do
psiv=n1**(-2.0)*((2.0*3.141592653)**0.5*g**3.0)**(-1.0)*sum2   

end subroutine

!K(4)
subroutine psi4(x,g,n1,psiv)
implicit none
real(8),intent(in)::x(:),g  !input, pilot bandwidth, general psi at given order
integer(8),intent(in)::n1
real(8),intent(out)::psiv   !general psi at given order
integer(8)::c1,c2
real(8)::sum1,sum2

sum1=0.0
sum2=0.0
do c1=1,n1
   do c2=1,n1
      sum1=(x(c1)-x(c2))**2.0/2.0/g**2.0 
      sum2=sum2+(3.0*dexp(-sum1)/g**2.0&
      -6.0*(x(c1)-x(c2))**2.0*dexp(-sum1)/g**4.0&       !K(4), checked
      +(x(c1)-x(c2))**4.0*dexp(-sum1)/g**6.0)            
   end do
end do
psiv=n1**(-2.0)*((2.0*3.141592653)**0.5*g**3.0)**(-1.0)*sum2   

end subroutine



!*************GRNN prediction with SCV BW************
subroutine BW_SCV(fc1,inx,outy,nr,nc)
implicit none

real(8),intent(in)::inx(:,:),outy(:)
integer(8),intent(in)::fc1,nr,nc
integer(8)::c1,c2,c3,c4,fc2,fc3    !counters
real(8),allocatable::sd(:),bw(:),outyest(:),h1(:),t1(:)
real(8)::mins,maxs,vars,kurts,rmses,mares,ces,ioads,pis,as,ss,& 
mces,mioads,mpis !Performance criteria
real(8)::a1,a2,a3,a4,tmin
real(8)::g1,g2,g3,g4,epsi6,epsi10,epsi4,epsi8,C_hat

allocate(sd(nc))
allocate(bw(nc))
allocate(outyest(nr))
allocate(h1(10))
allocate(t1(10))

bw=0.0

!Estimate bandwidths (BCV)
!Divide entire searching range into 10 sub areas; find min. of 10 areas
!Range from 0.0~1/3*(max.-min.)
do c2=1,nc
   call sds(inx(1:nr,c2),nr,sd(c2)) 
   
   !Based upon 2-stage Smoothing cross validation bandwidth estimator(Wand& Jones 1995) pp.78 assume L=K=N(0,1)
   g1=(2.0/7.0/nr)**(1.0/9.0)*2.0**0.5*sd(c2)     !Pilot bandwidth for L at order 6
   call psi6(inx(1:nr,c2),g1,nr,epsi6)
   g2=(2.0/11.0/nr)**(1.0/13.0)*2.0**0.5*sd(c2)   !Pilot bandwidth for L at order 10 
   call psi10(inx(1:nr,c2),g2,nr,epsi10)
   g3=(-6.0/(2.0*3.141592653)**0.5/epsi6/nr)**(1.0/7.0)
   g4=(-210.0/(2.0*3.141592653)**0.5/epsi10/nr)**(1.0/11.0) 
   call psi4(inx(1:nr,c2),g3,nr,epsi4)
   call psi8(inx(1:nr,c2),g4,nr,epsi8)
   C_hat=(441.0/64.0/3.141592653)**(1.0/18.0)*(4.0*3.141592653)**(-1.0/5.0)&
*epsi4**(-2.0/5.0)*epsi8**(-1.0/9.0)
   
   h1=0.0
   t1=0.0
   a1=0.0001    
   a4=(maxval(inx(1:nr,c2))-minval(inx(1:nr,c2)))
   do c3=1,10
      a1=a1+(c3-1)*a4/10
      a3=a1+c3*a4/10
      a2=(a1+a3)/2.0
      call GSS(a1,a2,a3,inx(1:nr,c2),nr,C_hat,t1(c3),h1(c3))
    end do   
    
    tmin=maxval(t1)
    do c4=1,10
       if (t1(c4)<tmin) then
           tmin=t1(c4)
           bw(c2)=h1(c4)
       else
           tmin=tmin
           bw(c2)=bw(c2)
       end if        
     end do   
end do

!GRNN prediction
call GRNN(inx,outy,nr,nc,bw,outyest)

!Performance criteria
call SPOM(outy,outyest,nr,mins,maxs,as,vars,ss,kurts)
call RMSE(outy,outyest,nr,rmses)
call MARE(outy,outyest,nr,mares)

call CE(outy,outyest,nr,ces)
call IoAd(outy,outyest,nr,ioads)
call PI(outy,outyest,nr,pis)

call MCE(outy,outyest,nr,mces)
call MIoAd(outy,outyest,nr,mioads)
call MPI(outy,outyest,nr,mpis)

!Output summary
!Detial results
write(fc1,*)"Estimated output:"
do c1=1,nr
   write(fc1,*)outyest(c1)
end do
write(fc1,*)

write(fc1,*)"Prediction performance:"
write(fc1,*)"Min. error %:",mins
write(fc1,*)"Max. error %:",maxs
write(fc1,*)"Mean. error:",as
write(fc1,*)"Stdev. error %:",vars
write(fc1,*)"Skew. error %:",ss
write(fc1,*)"Kurt. error %:",kurts
write(fc1,*)"RMSE:",rmses
write(fc1,*)"MARE:",mares
write(fc1,*)"CE:",ces
write(fc1,*)"IoAd:",ioads
write(fc1,*)"PI:",pis
write(fc1,*)"MCE:",mces
write(fc1,*)"MIoAd:",mioads
write(fc1,*)"MPI:",mpis
write(fc1,*)"******************************"

!Overall results
fc2=fc1+100
write(fc2,'(14F11.5)')mins,maxs,as,vars,ss,kurts,rmses,mares,ces,&
ioads,pis,mces,mioads,mpis

!Smoothing parameters
fc3=fc2+100
write(fc3,*)(bw(c2),c2=1,nc)

deallocate(sd)
deallocate(bw)
deallocate(outyest)
deallocate(h1)
deallocate(t1)

end subroutine



end Module
