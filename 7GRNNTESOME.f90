!  7GRNNTESOME.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  3/28/2013 3:57:52 PM
!  Compiled by XUYUAN LI
!  The University of Adelaide
!  Open sources code (application version) for the following journal paper:
!********************************************************************
! Li X., Zecchin A.C. and Maier H.R. 2014, 'Selection of smoothing parameter estimators 
! for General Regression Neural Networks - applications to hydrological and water resources modelling', 
! Environmental Modelling and Software, accepted May 6, 2014
!********************************************************************

Module GRNN_TESOME
  use GFS
  contains
  
!Optimiser 1D (GSS)
!This code is based upon 'NUMERICAL RECIPES IN FORTRAN77: THE ART OF SCIENTIFIC COMPUTING
!Routine for Golden Section Search
!Input boundary values, mid-value
!return the value minimising function
subroutine GSS2(ax,bx,cx,in,out,ro,co,minf,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:,:),out(:)
integer(8),intent(in)::ro,co
real(8),intent(out)::minf,minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(dabs(cx-bx)>dabs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=ESSO(in,out,ro,co,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=ESSO(in,out,ro,co,x2)
tol=0.0001
do while (dabs(x3-x0)>tol*(dabs(x1)+dabs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=ESSO(in,out,ro,co,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=ESSO(in,out,ro,co,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine
!****************************End of GSS*********************************

!Function ESSO(h)
real(8) function ESSO(x,y,xr,xc,hg)
implicit none
real(8),intent(in)::x(:,:),y(:),hg
integer(8),intent(in)::xr,xc
real(8),allocatable::hgm(:),ye(:)
integer(8)::c1,c2

allocate(hgm(xc))
allocate(ye(xr))
do c1=1,xc
   hgm(c1)=hg
end do

call GRNN(x,y,xr,xc,hgm,ye)

ESSO=0.0
do c2=1,xr
   ESSO=ESSO+dabs(ye(c2)-y(c2))  !SE
end do
   ESSO=ESSO/real(xr)

deallocate(hgm)
deallocate(ye)

end function

!*************GRNN prediction with trial & error (SO)************
subroutine BW_TESME(fc1,inx,outy,nr,nc)
implicit none

real(8),intent(in)::inx(:,:),outy(:)
integer(8),intent(in)::fc1,nr,nc
integer(8)::c1,c2,c3,c4,fc2,fc3    !counters
real(8),allocatable::sd(:),bw(:),outyest(:),h1(:),t1(:)
real(8)::a1,a2,a3,a4,tmin
real(8)::mins,maxs,vars,kurts,rmses,mares,ces,ioads,pis,as,ss,& 
mces,mioads,mpis !Performance criteria

allocate(sd(nc))
allocate(bw(nc))
allocate(outyest(nr))
allocate(h1(10))
allocate(t1(10))

bw=0.0

!Estimate bandwidths (GRR)
   h1=0.0
   t1=0.0
   a1=0.0001    
   a4=(maxval(inx)-minval(inx))
   do c3=1,10
      a1=a1+(c3-1)*a4/10
      a3=a1+c3*a4/10
      a2=(a1+a3)/2.0
      call GSS2(a1,a2,a3,inx,outy,nr,nc,t1(c3),h1(c3)) 
    end do   
    
    tmin=maxval(t1)
    do c4=1,10
       if (t1(c4)<tmin) then
           bw(1)=h1(c4)
           tmin=t1(c4)
       else
           bw(1)=bw(1)
           tmin=tmin
       end if        
     end do 

do c2=2,nc  
   bw(c2)=bw(1)
end do

!GRNN prediction
call GRNN(inx,outy,nr,nc,bw,outyest)

!Performance criteria
call SPOM(outy,outyest,nr,mins,maxs,as,vars,ss,kurts)
call RMSE(outy,outyest,nr,rmses)
call MARE(outy,outyest,nr,mares)

call CE(outy,outyest,nr,ces)
call IoAd(outy,outyest,nr,ioads)
call PI(outy,outyest,nr,pis)

call MCE(outy,outyest,nr,mces)
call MIoAd(outy,outyest,nr,mioads)
call MPI(outy,outyest,nr,mpis)

!Output summary
!Detial results
write(fc1,*)"Estimated output:"
do c1=1,nr
   write(fc1,*)outyest(c1)
end do
write(fc1,*)

write(fc1,*)"Prediction performance:"
write(fc1,*)"Min. error %:",mins
write(fc1,*)"Max. error %:",maxs
write(fc1,*)"Mean. error:",as
write(fc1,*)"Stdev. error %:",vars
write(fc1,*)"Skew. error %:",ss
write(fc1,*)"Kurt. error %:",kurts
write(fc1,*)"RMSE:",rmses
write(fc1,*)"MARE:",mares
write(fc1,*)"CE:",ces
write(fc1,*)"IoAd:",ioads
write(fc1,*)"PI:",pis
write(fc1,*)"MCE:",mces
write(fc1,*)"MIoAd:",mioads
write(fc1,*)"MPI:",mpis
write(fc1,*)"******************************"

!Overall results
fc2=fc1+100
write(fc2,'(14F11.5)')mins,maxs,as,vars,ss,kurts,rmses,mares,ces,&
ioads,pis,mces,mioads,mpis

!Smoothing parameters
fc3=fc2+100
write(fc3,*)(bw(c2),c2=1,nc)

deallocate(sd)
deallocate(bw)
deallocate(outyest)
deallocate(h1)
deallocate(t1)

end subroutine



end Module
